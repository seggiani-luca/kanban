\documentclass[9pt,a4paper]{article}
\usepackage[margin=1cm]{geometry}

% font
\usepackage[scaled]{helvet}
\renewcommand{\rmdefault}{phv}

% paragraph spacing
\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}
\linespread{0.85}

% lists
\usepackage{enumitem}
\setlist[itemize]{noitemsep, topsep=0pt, partopsep=0pt, parsep=0pt, leftmargin=*}
\setlist[enumerate]{noitemsep, topsep=0pt, partopsep=0pt, parsep=0pt, leftmargin=*}

% section spacing
\usepackage{titlesec}
\titleformat{\section}{\bfseries\small}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{6pt}{1pt}

% code
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\scriptsize,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  stringstyle=,
  numbers=left,
  numberstyle=\ttfamily\tiny,
  frame=none,
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  tabsize=2,
  aboveskip=2pt,
  belowskip=2pt,
  lineskip=0pt,
  xleftmargin=0pt,
  xrightmargin=0pt
}

\begin{document}
% titolo
\noindent
\textbf{Documentazione kanban v0.0} \hfill 2025 - Luca Seggiani

\section{Morale}
Si presenta l'implementazione di  un’applicazione distribuita che implementi il metodo di gestione del lavoro basato su \textbf{kanban}.
I principi che sono si sono voluti seguire sono:
\begin{itemize}
	\item Protocollo di trasmissione livello \textit{application} basato su stringhe ASCII separate da ritorni carrello (\lstinline|\n|), leggibili da uomo, ispirato a SMTP. Queste stringhe vanno a rappresentare \textbf{comandi} dell'applicazione;
	\item Design il più semplice e robusto possibile: no allocazioni sull'heap, client e server in multiplexing su un singolo thread. 
\end{itemize}

\section{Moduli}
La struttura del progetto è divisa in \textit{moduli}.
Sia client che server implementano 3 moduli relativi alle funzionalità di base:
\begin{itemize}
	\item \lstinline|core/|: implementa la logica vera e propria della lavagna;
	\item \lstinline|net/|: il \textit{modulo di rete}, astrae i socket. Nel server, fornisce il concetto di \lstinline|connection| con un client;
	\item \lstinline|watch/|: implementa il meccanismo di controllo sui client attraverso \lstinline|PING_USER| e \lstinline|PONG_LAVAGNA|. 
\end{itemize}

Per il client si ha il modulo aggiuntivo \lstinline|rev/|, che si occupa della componente peer-to-peer di revisione di card fra client.

\section{Costanti e strutture condivise}
Si definiscono alcune costanti e strutture condivise:
\begin{itemize}
	\item \lstinline|card/|: definisce il tipo \lstinline|card| di una kanban:
\begin{lstlisting}[language=C++]	
typedef struct {
  card_id id;								// id (se e' 0 la card e' nulla)
  char desc[CARD_DESC_LEN]; // testo attivita'
  int user;									// utente che la sta implementando o l'ha implementata
  struct tm timestamp;			// timestamp dell'ultima modifica
} card;
\end{lstlisting}

Le card vengono allocate in una pool statica: si possono ottenere e liberare nuove card con le funzioni \lstinline|alloc_card()| e \lstinline|free_card(card *p)|, dalla semantica simile alle \lstinline|malloc()| e \lstinline|free()| della \lstinline|stdlib|.
	\item \lstinline|cmd/|: definisce il tipo \lstinline|cmd| per i comandi scambiati fra client e server:
\begin{lstlisting}[language=C++]	
typedef struct {
  cmd_type type;									// tipo di comando
  const char *args[MAX_CMD_ARGS];	// argomenti del comando, in una lista terminata da NULL
} cmd;
\end{lstlisting}
Per comodità si è scelto di rappresentare gli argomenti come una lista di puntatori a stringhe, terminati da NULL.
\begin{itemize}
	\item Per la creazione di un comando, si possono sfruttare le initializer list del C:
\begin{lstlisting}[language=C++]	
cmd cm = {.type = TIPO_COMANDO,
					.args = {"arg0", "arg1", /* NULL di default ! */ }};
\end{lstlisting}
e quindi serializzare usando l'helper \lstinline|cmd_to_buf(const cmd *cm, char *buf)|, che assume una dimensione di buffer predefinita:
\begin{lstlisting}[language=C++]	
char buf[CMD_BUF_SIZE];
cmd_to_buf(cm, buf);
// qui si puo' fare la send() di buf
\end{lstlisting}
	\item Per la ricezione di comandi si può deserializzare usando l'helper \lstinline|buf_to_cmd(char *buf, cmd *cm)|, che si aspetta di trovare un comando vuoto (principalmente per la sicurezza della terminazione della lista di argomenti):
\begin{lstlisting}[language=C++]	
cmd cm = {0}; // tutti gli elementi di .args sono NULL !
buf_to_cmd(buf, &cm);
// ora cm puo' essere gestito
\end{lstlisting}
\end{itemize}

	\item \lstinline|core_const.h| e \lstinline|net_const.h| contengono costanti relative rispettivamente ai core (numero massimo di client, ecc..) e ai moduli di rete (indirizzi, numeri di porta, ecc...).
\end{itemize}

\section{Gestione rete}
L'idea dietro i moduli di rete è che questi separano la logica di lettura e scrittura su socket dai moduli core, che devono preoccuparsi solo di logica relativa alla lavagna. In particolare, abbiamo che:
\begin{itemize}
	\item Le operazioni di \textit{ricezione} (\lstinline|recv()|) avvengono in multiplexing, e quando possibile. Questo significa appena si ha tempo per il server, e quando si hanno \textit{"momenti morti"} per il client: ad esempio quando si fanno richieste o quando si va in attesa simulando l'elaborazione di una card;
	\item Le operazioni di \textit{invio} \lstinline|send()| sono sincrone e bloccanti, in quanto la mole di comandi inviati è ridotta.
\end{itemize}

Il compito vero e proprio dei moduli di rete è quindi:
\begin{enumerate}
	\item Ottenere comandi dallo stack di rete del sistema operativo;
	\item Smistare tali comandi fra i vari moduli. Questo si fa sfruttando una mappa definita sui tipi comando, accessibile attraverso \lstinline|type_to_mod(cmd_type type)|:
\begin{lstlisting}[language=C++]	
/*
 * Discrimina i tipi di comando sulla base del modulo che li deve gestire
 */
typedef enum {
  CORE,  // comandi standard
  WATCH, // comandi di controllo client (PING_USER, PONG_LAVAGNA)
  PEER   // comandi di revisione fra peer (REVIEW_CARD, ACK_REVIEW_CARD)
} mod_type;
\end{lstlisting}
	\item Inviare indietro risposte, ottenute sempre dai moduli.
\end{enumerate}

\section{Server}
Per il server questa corrispondenza è diretta, in quanto tutti i comandi ricevuti sono provenienti da client, e il modulo di rete deve quindi limitarsi a smistarli fra modulo core e modulo watch.
Non esiste quindi una funzione \lstinline|recv()|, ma una \lstinline|listen_net()| che gestisce in multiplexing le richieste arrivate al server, oltre che ai timer usati per gestire il modulo watch.
La sua implementazione è basata sulla \lstinline|select()|:
\begin{lstlisting}[language=C++]	
void listen_net() {
  // gestisci i timer
  for (int i = 0; i < MAX_CLIENTS; i++) {
		handle_timer(&connections[i]);
  }

  // scansiona con la select
  select(fdmax + 1, &read_set, NULL, NULL, &tv);

  for (int i = 0; i <= fdmax; i++) {
    // controlla che si qualcosa da leggere
    if (!FD_ISSET(i, &read_set)) {
      continue;
    }

    if (i == listen_sock) { // accetta nuovo client
      accept_client();
    } else if (i == STDIN_FILENO) { // gestisci console amminisratore
      handle_client(&admin_conn);
    } else { // gestisci client
      handle_client_sock(i);
    }
  }
}
\end{lstlisting}
Notiamo che si prevede un client speciale, con socket \lstinline|STDIN_FILENO|, inteso come l'"amministratore".
Questo non è altro che il client di cui si prende il controllo interagendo con riga di comando offerta dal server stesso, e viene fornito per creare nuove card effettuare operazioni di debugging (e.g. spostare card). 

Si rende poi disponibile una \lstinline|send_client(client_id cl_id, const cmd *cm)|.

Notiamo infine che modulo net e core del server usano astrazioni diverse per i client.
Un client per il modulo rete è infatti rappresentato da una \textit{connessione}:
\begin{lstlisting}[language=C++]	
typedef struct {
  int sock;											// socket della connessione (se e' 0 la connessione e' nulla)
  unsigned short port;					// porta della connessione
  char read_buf[CMD_BUF_SIZE];	// buffer di lettura
  int read_len;									// caratteri letti in buffer
} connection;
\end{lstlisting}
mentre nel modulo core si mantiene informazione relativa alla kanban:
\begin{lstlisting}[language=C++]	
typedef struct {
  client_id id;							// id (se e' 0 il client e' nullo)
  client_sts sts;						// stato
  card *handling;						// puntatore alla card che sta gestendo (se e' NULL sta aspettando una card)
  struct timespec deadline;	// deadline del timer
  int sent_pong;						// un flag che rappresenta se si sta aspettando un ping dal client
} client;
\end{lstlisting}

Si nota la stretta dipendenza fra il modulo watch e il modulo core: quest'ultimo fornisce appositamente due header, \lstinline|core.h| e \lstinline|core_watch.h|, di cui il secondo più intimo e riservato al modulo watch. 

\section{Client}
Per il client si ha una complicazione data dal fatto che è il modulo core a portare avanti l'elaborazione, effettuando operazioni di ricezione e invio su propria discrezione.
Allo stesso tempo, il modulo di rete deve essere pronto a gestire comandi provenienti sia dal server che da altri client, e questi comandi potrebbero dover essere gestiti da uno qualsiasi fra i moduli core, watch e rev.
Per questo si rende disponibile una funzione \lstinline|recv_multi(cmd *cm, int block)|, che gestisce in multiplexing le richieste, e smista finché non si ottiene un comando diretto al modulo core. In tal caso si restituisce il comando, rimandando alla prossima chiamata le gestione delle richieste successive. Il flag \lstinline|block| permette inoltre di specificare se si vuole che la funzione blocchi fino alla ricezione di un comando diretto a core, o se si vuole uscire dopo un timeout di 1 secondo.
In questo modo si riesce a gestire le richieste dirette al client nei \textit{"momenti morti"} accennati sopra.
\begin{lstlisting}[language=C++]	
int recv_multi(cmd *cm, int block) {
  while (1) {
    // scansiona con la select
    select(fdmax + 1, &read_set, NULL, NULL, block ? NULL : &tv);

    // c'e' qualcosa sul socket UDP?
    unsigned short who;
    if (FD_ISSET(udp_sock, &read_set)) {
      if (handle_cmd(who, cm) > 0)
        return 1; // e' core, esci
    }

    // c'e' qualcosa sul socket TCP?
    if (FD_ISSET(tcp_sock, &read_set)) {
      if (handle_cmd(0, cm) > 0)
        return 1; // e' core, esci
    }
  }
}
\end{lstlisting}

Si rendono poi disponibili una \lstinline|send_server(const cmd *cm)| per l'invio a server e una \lstinline|send_peer(unsigned short who, const cmd *cm)| per l'invio a server.

L'implementazione del client diventa quindi semplice:
\begin{lstlisting}[language=C++]	
int client_loop() {
  while (1) {
    // ottieni una card
    card c = {0};
    unsigned short clients[MAX_CLIENTS];
    int num_clients;
    get_card(&c, clients, &num_clients);
		
		// aspetta un tempo casuale
    rand_wait();

    // chiedi review
    for (int i = 0; i < num_clients; i++) {
      unsigned short client = clients[i];
      req_review(client);
    }

    // processa la card
    card_done();
  }
}
\end{lstlisting}

\section{Compilazione}
La compilazione è gestita da \lstinline|make|, con i target \lstinline|make lavagna| e \lstinline|make client|. 
Sono disponibili i target \lstinline|make run_lavagna| (avvia una lavagna predefinita) e \lstinline|make run_clients| (avvia 4 client) per il testing.

\end{document}
